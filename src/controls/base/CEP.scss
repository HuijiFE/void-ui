/**
 * 
 * CEP
 * The css class naming rule based on component, something like BEM.
 * 
 */

/*----------  Component  ----------*/

@function class-comp($component) {
  @if $component != to-lower-case($component) {
    @error 'Must use lower case class name for a component. "#{$component}"';
  }
  @return '#{$namespace}-#{$component}';
}

/**
 * @include comp('button') {}
 * 
 * .vd-button {}
 */
@mixin comp($component) {
  $C: class-comp($component) !global;

  .#{$C} {
    @content;
  }
}

/*----------  Element  ----------*/

@function class-elem($element) {
  @return '#{$C}_#{$element}';
}

/**
 * @include comp('button') {
 *   @include elem('icon') {}
 * }
 * 
 * .vd-button {
 *   .vd-button_icon {}
 * }
 */
@mixin elem($element) {
  $E: $element !global;
  $selector: &;

  @at-root {
    #{$selector} {
      .#{class-elem($element)} {
        @content;
      }
    }
  }
}

/**
 * @include comp('list') {
 *   @include elem-adjacent('item') {}
 * }
 * 
 * .vd-list {
 *   .vd-list_item + .vd-list_item {}
 * }
 */
@mixin elem-adjacent($element-former, $element-target: null) {
  @if not $element-target {
    $element-target: $element-former;
  }
  $selector: &;

  @at-root {
    #{$selector} {
      .#{class-elem($element-former)} + .#{class-elem($element-target)} {
        @content;
      }
    }
  }
}

/**
 * @include comp('list') {
 *   @include elem-general('item') {}
 * }
 * 
 * .vd-list {
 *   .vd-list_item ~ .vd-list_item {}
 * }
 */
@mixin elem-general($element-former, $element-target: null) {
  @if not $element-target {
    $element-target: $element-former;
  }
  $selector: &;

  @at-root {
    #{$selector} {
      .#{class-elem($element-former)} ~ .#{class-elem($element-target)} {
        @content;
      }
    }
  }
}

/*----------  Property  ----------*/

@function class-prop($property, $value) {
  @return '#{$namespace}p-#{$property}_#{$value}';
}

/**
 * @include comp('button') {
 *   @include prop(( skin: 'plain', theme: 'dark', )) {}
 * }
 * 
 * .vd-button.vdp-skin-plain.vdp-theme-dark {}
 * 
 * NOTE: The prop mixin is only for components, not for elements
 */
@mixin prop($properties-map) {
  $props-selector: '';
  @each $property, $value in $properties-map {
    $props-selector: '#{$props-selector}.#{class-prop($property, $value)}';
  }

  @at-root {
    .#{$C}#{$props-selector} {
      @content;
    }
  }
}

/*----------  Status  ----------*/

/**
 * @include comp('menu-item') {
 *   @include when('selected') {}
 * }
 * 
 * .menu-item.is-selected {}
 * 
 * ----
 * 
 * @include comp('list') {
 *   @include elem('item') {
 *     @include when('selected', 'raised') {}
 *   }
 * }
 * 
 * .vd-list {
 *   .vd-list_item.is-selected.is-raised {}
 * }
 */
@mixin when($status-list...) {
  $selector: &;
  $status-selector: '';
  @each $status in $status-list {
    $status-selector: '#{$status-selector}.is-#{$status}';
  }

  @at-root {
    #{$selector}#{$status-selector} {
      @content;
    }
  }
}

/*----------  Atomic  ----------*/

// Define a atomic rule.
@mixin define-atom($name) {
  @at-root {
    .#{$namespace}a-#{$name},
    %#{$namespace}a-#{$name} {
      @content;
    }
  }
}
// Extend a atomic rule.
@mixin extend-atom($name) {
  @extend .#{$namespace}a-#{$name};
}
// Define a abstract atomic rule.
@mixin abstract-atom($name) {
  @at-root {
    %#{$namespace}a-#{$name} {
      @content;
    }
  }
}
// Inherit a atomic rule.
@mixin inherit-atom($name) {
  @extend %#{$namespace}a-#{$name};
}
